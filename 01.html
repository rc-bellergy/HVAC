<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Digital Twin Demo – Three.js</title>
  <style>
    :root{
      --bg:#0b1220;
      --hud:#0e1a2f;
      --accent:#24d6ff;
      --accent2:#00ffa9;
      --warn:#ff7b00;
      --alert:#ff355d;
      --glow: drop-shadow(0 0 6px #4cf2ff) drop-shadow(0 0 18px #4cf2ff);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 60% -20%, #294b7a33 0%, transparent 60%), var(--bg); color:#dbe9ff; font-family:var(--sans);}
    #app{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto;}
    /* Top HUD */
    .hud{
      display:flex; gap:.6rem; align-items:center; padding:.6rem .75rem; flex-wrap:wrap;
      background:linear-gradient(180deg, #0b1527ee, #08101cee);
      border-bottom:1px solid #1f3355;
      backdrop-filter: blur(6px) saturate(120%);
      z-index:12;
    }
    .hud .brand{font-weight:700; letter-spacing:.3px; color:#e8f7ff;}
    .hud .dot{width:8px; height:8px; border-radius:50%; background:#49f3ff; box-shadow:0 0 12px #49f3ff;}
    .hud .sp{flex:1}
    .hud .btn, .hud .seg input+label{
      color:#dff7ff; background:#0d233d; border:1px solid #1f406a; border-radius:8px; padding:.45rem .7rem; cursor:pointer;
      display:inline-flex; align-items:center; gap:.4rem; transition:.2s; font-family:var(--mono); font-size:.9rem;
    }
    .hud .btn:hover{background:#123055}
    .hud .seg{display:inline-flex; border-radius:10px; overflow:hidden; border:1px solid #1f406a}
    .hud .seg input{display:none}
    .hud .seg label{padding:.45rem .65rem; background:#0d233d; border-right:1px solid #1f406a; cursor:pointer; font-family:var(--mono)}
    .hud .seg label:last-child{border-right:none}
    .hud .seg input:checked + label{background:#143b66; color:#8ff6ff}
    .legend{
      display:flex; gap:10px; align-items:center; font-size:.9rem; color:#b9d7ff;
      filter: var(--glow);
    }
    .chip{display:inline-flex; align-items:center; gap:.35rem; padding:.25rem .5rem; background:#0a1a2f; border:1px solid #1e3a63; border-radius:999px}
    .sw{width:10px;height:10px;border-radius:3px;box-shadow:0 0 8px currentColor}
    .sw.ok{color:#00ffa9;background:#00ffa9}
    .sw.warn{color:#ff7b00;background:#ff7b00}
    .sw.alert{color:#ff355d;background:#ff355d}
    /* Canvas layers */
    #three {position:relative; width:100%; height:100%; overflow:hidden;}
    canvas.webgl{display:block; position:absolute; inset:0; width:100%; height:100%}
    /* CSS2D labels */
    .label{
      padding:.25rem .45rem; background:#051126cc; border:1px solid #1c365d; color:#bfe9ff; border-radius:6px; font:600 12px var(--mono);
      backdrop-filter: blur(3px); box-shadow:0 0 12px #3af2ff33 inset, 0 0 14px #3af2ff22;
      white-space:nowrap;
    }
    .label .value{color:#eaffff}
    .label.warn{border-color:#ff7b00; color:#ffd9b5; box-shadow:0 0 14px #ff7b0033 inset}
    .label.alert{border-color:#ff355d; color:#ffd5df; box-shadow:0 0 14px #ff355d33 inset}
    /* Right panel */
    .side{
      position:fixed; right:10px; top:64px; bottom:10px; width:320px; max-width:86vw; display:grid; grid-template-rows:auto auto 1fr;
      gap:.6rem; padding:.6rem; background:linear-gradient(180deg, #081221f0, #091425ee);
      border:1px solid #1c355c; border-radius:12px; z-index:11; backdrop-filter: blur(8px);
    }
    .panel{border:1px solid #1f3a62; border-radius:10px; background:#0a182b; padding:.6rem}
    .panel h3{margin:.1rem 0 .6rem 0; font-size:1rem; color:#e5f3ff}
    .kv{display:grid; grid-template-columns: 1fr auto; gap:.35rem .8rem; align-items:center; font-family:var(--mono); color:#bfe6ff}
    .big{font-size:1.9rem; font-weight:800; letter-spacing:.5px}
    #spark{width:100%; height:70px; background:#051022; border-radius:8px}
    .footer{
      display:flex; justify-content:center; gap:1rem; padding:.4rem; color:#7aa7d6; font:600 12px var(--mono); border-top:1px solid #1e3352; background:#081427;
    }
    /* Mobile tweaks */
    @media (max-width:768px){
      .hud{gap:.4rem}
      .side{right:6px; top:auto; bottom:6px; width:auto; grid-template-rows:auto; grid-auto-rows:auto}
      .big{font-size:1.4rem}
      #spark{height:54px}
    }
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="app">
    <div class="hud">
      <span class="dot"></span>
      <div class="brand">Factory Digital Twin</div>
      <div class="legend">
        <span class="chip"><span class="sw ok"></span>Normal</span>
        <span class="chip"><span class="sw warn"></span>Warning</span>
        <span class="chip"><span class="sw alert"></span>Alarm</span>
      </div>
      <div class="sp"></div>
      <div class="seg" role="group" aria-label="Flow">
        <input type="radio" id="flowOff" name="flow" value="0">
        <label for="flowOff">Flow Off</label>
        <input type="radio" id="flowOn" name="flow" value="1" checked>
        <label for="flowOn">Flow On</label>
        <input type="radio" id="flowFast" name="flow" value="2">
        <label for="flowFast">Turbo</label>
      </div>
      <button class="btn" id="btnReset">Reset Camera</button>
      <button class="btn" id="btnTheme">Theme</button>
    </div>

    <div id="three"></div>

    <div class="footer">Three.js Digital Twin Demo • Glow pipelines, animated flow, live labels, and bloom</div>
  </div>

  <aside class="side" id="side">
    <div class="panel">
      <h3>Selected Asset</h3>
      <div class="kv">
        <div>ID</div><div id="selId">–</div>
        <div>Name</div><div id="selName">Tap an object</div>
        <div>Status</div><div id="selStatus">–</div>
        <div>Temp</div><div id="selTemp">–</div>
        <div>Load</div><div id="selLoad">–</div>
      </div>
    </div>
    <div class="panel">
      <h3>Process Throughput</h3>
      <div class="big"><span id="throughput">0.00</span> t/h</div>
      <canvas id="spark"></canvas>
    </div>
    <div class="panel">
      <h3>Actions</h3>
      <div style="display:flex; gap:.5rem; flex-wrap:wrap">
        <button class="btn" id="btnStart">Start Line</button>
        <button class="btn" id="btnStop">Stop Line</button>
        <button class="btn" id="btnPulse">Pulse Alarm</button>
      </div>
    </div>
  </aside>

  <script type="module">
    // Import Three.js modules
    // Import Three.js modules
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

    // ---------- Scene setup ----------
    const container = document.getElementById('three');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x08101e);
    scene.fog = new THREE.FogExp2(0x0a1326, 0.035);

    const camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.1, 2000);
    camera.position.set(12, 12, 20);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.2;
    renderer.domElement.classList.add('webgl');
    container.appendChild(renderer.domElement);

    // CSS2D overlay for labels
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(container.clientWidth, container.clientHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.inset = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    container.appendChild(labelRenderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(6, 0, 0);
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.minDistance = 6;
    controls.maxDistance = 60;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    // Lights
    const hemi = new THREE.HemisphereLight(0x9fdfff, 0x0a1730, 1.2);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xaed4ff, 1.2);
    dir.position.set(12, 18, 8);
    scene.add(dir);

    // ---------- Postprocessing (bloom) ----------
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), 1.2, 0.9, 0.15);
    bloomPass.threshold = 0.18;
    bloomPass.strength = 1.6;      // overall glow
    bloomPass.radius = 0.9;
    composer.addPass(bloomPass);

    // ---------- Helpers / materials ----------
    // Grid floor (canvas texture with glow)
    function makeGridTexture(size=1024, majorEvery=8) {
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const g = c.getContext('2d');
      g.fillStyle = '#061226';
      g.fillRect(0,0,size,size);
      g.strokeStyle = '#2b6db8';
      g.globalAlpha = .14;
      g.lineWidth = 1;
      for(let i=0;i<size;i+=size/64){
        g.beginPath(); g.moveTo(i,0); g.lineTo(i,size); g.stroke();
        g.beginPath(); g.moveTo(0,i); g.lineTo(size,i); g.stroke();
      }
      // major lines
      g.strokeStyle = '#4cc3ff';
      g.globalAlpha = .25; g.lineWidth = 1.2;
      for(let i=0;i<=size;i+=size/majorEvery){
        g.beginPath(); g.moveTo(i,0); g.lineTo(i,size); g.stroke();
        g.beginPath(); g.moveTo(0,i); g.lineTo(size,i); g.stroke();
      }
      return new THREE.CanvasTexture(c);
    }

    const gridTex = makeGridTexture();
    gridTex.wrapS = gridTex.wrapT = THREE.RepeatWrapping;
    gridTex.repeat.set(8,8);

    const floorMat = new THREE.MeshStandardMaterial({
      color: new THREE.Color(0x0b1a32),
      map: gridTex,
      metalness: 0.0,
      roughness: 1.0,
      transparent: true,
      opacity: 0.95
    });

    const floor = new THREE.Mesh(new THREE.PlaneGeometry(80, 46), floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.y = -0.001;
    scene.add(floor);

    // Subtle volumetric planes to fake light shafts
    const shaft = new THREE.Mesh(
      new THREE.PlaneGeometry(80, 16),
      new THREE.MeshBasicMaterial({ color: 0x5bbcff, transparent: true, opacity: 0.06, depthWrite: false })
    );
    shaft.position.set(8, 8, -6);
    shaft.rotation.x = -Math.PI/5;
    scene.add(shaft);

    // Utility: asset labeling
    function addLabel(obj, text) {
      const el = document.createElement('div');
      el.className = 'label';
      el.textContent = text;
      const label = new CSS2DObject(el);
      label.position.set(0, 1.6, 0);
      obj.add(label);
      return el;
    }

    // ---------- Pipe shader (animated dashes) ----------
    const pipeUniforms = {
      uTime: { value: 0 },
      uColorA: { value: new THREE.Color(0x47e1ff) },
      uColorB: { value: new THREE.Color(0x00ffa9) },
      uGlow:  { value: 1.0 },
      uSpeed: { value: 0.5 }, // will be updated by UI
      uStripe: { value: 26.0 },
      uMix: { value: 0.5 }
    };

    const pipeMat = new THREE.ShaderMaterial({
      uniforms: pipeUniforms,
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      vertexShader: `
        varying vec2 vUv;
        varying float vCurve;
        void main(){
          vUv = uv;
          // 'vCurve' as radial factor for edge glow
          vec3 transformed = position.xyz;
          vCurve = length(normal.xy);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed,1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        varying float vCurve;
        uniform float uTime;
        uniform vec3 uColorA;
        uniform vec3 uColorB;
        uniform float uGlow;
        uniform float uSpeed;
        uniform float uStripe;
        uniform float uMix;
        // Soft pulse wave
        float pulse(float x){ return 0.5 + 0.5 * sin(x); }
        void main(){
          float t = fract(vUv.x * uStripe - uTime * (0.6 + 1.2*uSpeed));
          float dash = smoothstep(0.1, 0.0, abs(t-0.5)); // sharp center
          float core = smoothstep(0.04, 0.0, abs(t-0.5)); // narrower
          vec3 col = mix(uColorA, uColorB, uMix);
          float edge = smoothstep(1.2, 0.2, vCurve); // rim glow
          float sparkle = 0.4 * pulse(uTime*2.0 + vUv.x*10.0);
          float alpha = clamp(dash*1.6 + edge*0.35 + sparkle*0.15, 0.0, 1.0);
          gl_FragColor = vec4(col * (1.0 + 2.0*core + 0.6*edge), alpha*uGlow);
        }
      `
    });

    // Helper: create tube along points
    function makePipe(points, radius=0.12) {
      const curve = new THREE.CatmullRomCurve3(points);
      const geom = new THREE.TubeGeometry(curve, Math.max(80, points.length*20), radius, 16, false);
      const mesh = new THREE.Mesh(geom, pipeMat);
      // faint casing
      const shell = new THREE.Mesh(
        new THREE.TubeGeometry(curve, Math.max(80, points.length*20), radius*1.35, 16, false),
        new THREE.MeshStandardMaterial({ color:0x0b2b49, metalness:0.2, roughness:0.5, transparent:true, opacity:0.08 })
      );
      const group = new THREE.Group();
      group.add(mesh, shell);
      return { group, curve };
    }

    // ---------- Assets (tanks, reactors, machines) ----------
    const PICK = []; // objects to raycast

    function makeTank(id, pos){
      const g = new THREE.Group(); g.position.copy(pos);
      const cyl = new THREE.Mesh(
        new THREE.CylinderGeometry(0.7, 0.8, 2.2, 32, 1, false),
        new THREE.MeshStandardMaterial({ color:0x2a70b7, roughness:0.2, metalness:0.1, emissive:0x0c5ca3, emissiveIntensity:0.6 })
      );
      const cap = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32),
        new THREE.MeshStandardMaterial({ color:0x9bd1ff, emissive:0x408cff, emissiveIntensity:1.0, roughness:0.4 })
      );
      cap.position.y = 1.2;
      const base = new THREE.Mesh(
        new THREE.CylinderGeometry(0.9, 0.95, 0.25, 32),
        new THREE.MeshStandardMaterial({ color:0x10233c, metalness:0.4, roughness:0.8 })
      );
      base.position.y = -1.2;
      g.add(cyl, cap, base);
      g.userData = { id, name:`Tank ${id}`, type:'tank', temp: 21+Math.random()*4, load: 0.5, state: 'ok' };
      const label = addLabel(g, `Tank ${id}`);
      PICK.push(cyl);
      cyl.userData.ref = g;
      scene.add(g);
      return g;
    }

    // Helix curve for reactor coil
    class HelixCurve extends THREE.Curve {
      constructor(radius=0.35, height=0.9, turns=4){ super(); this.r=radius; this.h=height; this.tu=turns; }
      getPoint(t){
        const a = t * this.tu * Math.PI * 2;
        const x = Math.cos(a) * this.r;
        const y = -0.45 + t * this.h;
        const z = Math.sin(a) * this.r;
        return new THREE.Vector3(x, y, z);
      }
    }

    function makeReactor(id, pos){
      const g = new THREE.Group(); g.position.copy(pos);
      const base = new THREE.Mesh(new THREE.CylinderGeometry(0.9,1.0,0.3,32),
        new THREE.MeshStandardMaterial({ color:0x24110a, roughness:0.8, metalness:0.1, emissive:0x802400, emissiveIntensity:0.3 }));
      base.position.y = -0.8;
      const body = new THREE.Mesh(new THREE.CylinderGeometry(0.7,0.7,1.4,36),
        new THREE.MeshStandardMaterial({ color:0x5a1a08, roughness:0.6, metalness:0.2, emissive:0xff6a2a, emissiveIntensity:0.9, transparent:true, opacity:0.85 }));
      const coil = new THREE.Mesh(new THREE.TubeGeometry(new HelixCurve(0.35,0.9,4), 200, 0.06, 12, false),
        new THREE.MeshBasicMaterial({ color:0xff8a3a, transparent:true, opacity:0.9 }));
      const rim = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.06, 16, 48),
        new THREE.MeshBasicMaterial({ color:0xffa25a, transparent:true, opacity:0.9 }));
      rim.position.y = 0.55;
      g.add(base, body, coil, rim);
      g.userData = { id, name:`Reactor ${id}`, type:'reactor', temp: 60+Math.random()*10, load: 0.7, state:'ok' };
      addLabel(g, `Reactor ${id}`);
      PICK.push(body);
      body.userData.ref = g;
      scene.add(g);
      return g;
    }

    function makeMachine(id, pos){
      const g = new THREE.Group(); g.position.copy(pos);
      const box = new THREE.Mesh(
        new THREE.BoxGeometry(2.2, 1.4, 1.2),
        new THREE.MeshStandardMaterial({ color:0x0d8a37, roughness:0.4, metalness:0.2, emissive:0x39ff78, emissiveIntensity:0.7, transparent:true, opacity:0.92 })
      );
      const frame = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(2.2,1.4,1.2)),
        new THREE.LineBasicMaterial({ color:0x9affc9, transparent:true, opacity:0.8 })
      );
      frame.position.set(0,0,0);
      g.add(box, frame);
      g.userData = { id, name:`Machine ${id}`, type:'machine', temp: 35+Math.random()*5, load: 0.5, state:'ok' };
      addLabel(g, `Machine ${id}`);
      PICK.push(box);
      box.userData.ref = g;
      scene.add(g);
      return g;
    }

    // ---------- Layout ----------
    const tanks = [];
    const reactors = [];
    const machines = [];

    // Positions tuned to resemble the reference composition
    for(let i=0;i<4;i++){
      tanks.push(makeTank(i+1, new THREE.Vector3(-12, 0, -6 + i*4)));
    }
    for(let i=0;i<4;i++){
      reactors.push(makeReactor(i+1, new THREE.Vector3(-2 + i*6, 0, 5.5)));
    }
    for(let i=0;i<5;i++){
      machines.push(makeMachine(i+1, new THREE.Vector3(-3 + i*5, 0, -4.8)));
    }

    // ---------- Pipe network ----------
    const pipes = [];
    // Outer rectangle perimeter
    const outlinePts = [
      new THREE.Vector3(-14, 0.8, -9),
      new THREE.Vector3(18, 0.8, -9),
      new THREE.Vector3(18, 0.8, 10),
      new THREE.Vector3(-14, 0.8, 10),
      new THREE.Vector3(-14, 0.8, -9)
    ];
    pipes.push(makePipe(outlinePts, 0.14));

    // Top horizontal main
    const mainTopPts = [
      new THREE.Vector3(-14, 1.6, 7.8),
      new THREE.Vector3(18, 1.6, 7.8)
    ];
    pipes.push(makePipe(mainTopPts, 0.16));

    // Drops from top main to reactors
    reactors.forEach((r) => {
      const p = r.position.clone();
      const drops = [
        new THREE.Vector3(p.x, 1.6, 7.8),
        new THREE.Vector3(p.x, 1.2, 6.7),
        new THREE.Vector3(p.x, 0.8, 6.0)
      ];
      pipes.push(makePipe(drops, 0.1));
    });

    // Midline link reactors -> machines
    const midPts = [
      new THREE.Vector3(-10.5, 0.8, 1.3),
      new THREE.Vector3(16.2, 0.8, 1.3)
    ];
    pipes.push(makePipe(midPts, 0.12));

    // Bottom horizontal return
    const bottomPts = [
      new THREE.Vector3(18, 0.6, -7.8),
      new THREE.Vector3(-14, 0.6, -7.8)
    ];
    pipes.push(makePipe(bottomPts, 0.16));

    // Machine taps to bottom and mid lines
    machines.forEach((m) => {
      const p = m.position.clone();
      pipes.push(makePipe([ new THREE.Vector3(p.x, 0.6, -7.8), new THREE.Vector3(p.x, 0.0, -5.3)], 0.1));
      pipes.push(makePipe([ new THREE.Vector3(p.x, 0.8, 1.3), new THREE.Vector3(p.x, 0.0, -4.2)], 0.08));
    });

    // Tanks feeder into mainTop
    tanks.forEach((t) => {
      const p = t.position.clone();
      pipes.push(makePipe([ new THREE.Vector3(-12.9, 1.6, p.z), new THREE.Vector3(-11.2, 1.6, p.z) ], 0.1));
    });

    // Place groups in scene
    pipes.forEach(p => scene.add(p.group));

    // ---------- Flow particles on the top main ----------
    function movingDot(color=0x8cf0ff){
      const m = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), new THREE.MeshBasicMaterial({ color, transparent:true, opacity:0.9 }));
      return m;
    }
    const topCurve = pipes[1].curve; // main top
    const dots = Array.from({length: 16}, (_,i)=> {
      const d = movingDot(i%2?0x8cf0ff:0x00ffa9);
      scene.add(d);
      return { mesh:d, t: Math.random(), speed: 0.04 + Math.random()*0.06 };
    });

    // ---------- Interactivity ----------
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selected = null;

    function setSelection(mesh){
      selected = mesh?.userData?.ref || null;
      if(selected){
        updateSide(selected);
      }else{
        document.getElementById('selId').textContent = '–';
        document.getElementById('selName').textContent = 'Tap an object';
        document.getElementById('selStatus').textContent = '–';
        document.getElementById('selTemp').textContent = '–';
        document.getElementById('selLoad').textContent = '–';
      }
    }

    function onPointer(e){
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ( (e.clientX - rect.left) / rect.width ) * 2 - 1;
      const y = -( (e.clientY - rect.top) / rect.height ) * 2 + 1;
      mouse.set(x,y);
      raycaster.setFromCamera(mouse, camera);
      const list = raycaster.intersectObjects(PICK, false);
      if(list.length>0) setSelection(list[0].object);
    }
    renderer.domElement.addEventListener('pointerdown', onPointer);

    // ---------- Telemetry simulation ----------
    const allAssets = [...tanks, ...reactors, ...machines];
    function tickTelemetry(){
      let throughput = 0;
      allAssets.forEach(g=>{
        // drift values
        const u = g.userData;
        const drift = (Math.random()-0.5)*0.6;
        u.load = THREE.MathUtils.clamp(u.load + drift*0.02, 0, 1.2);
        u.temp = u.temp + (Math.random()-0.5)*0.6;
        // state based on thresholds
        let state='ok';
        if(u.load>0.95 || u.temp>70) state='warn';
        if(u.load>1.05 || u.temp>80) state='alert';
        u.state = state;
        throughput += Math.max(0, u.load*0.2);
        // visual feedback
        const k = (g.children.find(c=>c.isMesh)||g); // first mesh
        const emissiveBoost = state==='ok'? 0.8 : state==='warn'? 1.3 : 1.7;
        if(k.material && 'emissiveIntensity' in k.material){
          k.material.emissiveIntensity = emissiveBoost;
          if(u.type==='machine'){
            k.material.color.set(state==='alert'?0x40141f: state==='warn'?0x2b4a0f: 0x0d8a37);
            k.material.emissive.set(state==='alert'?0xff355d: state==='warn'?0xff8a3a: 0x39ff78);
          }
          if(u.type==='reactor'){
            k.material.emissive.set(state==='alert'?0xff355d: state==='warn'?0xff8a3a: 0xff6a2a);
          }
        }
        // update label style
        const lbl = g.children.find(ch=>ch.isCSS2DObject)?.element;
        if(lbl){
          lbl.classList.toggle('warn', state==='warn');
          lbl.classList.toggle('alert', state==='alert');
          lbl.innerHTML = `${u.name}<br><span class="value">${u.load.toFixed(2)} load</span>`;
        }
      });
      document.getElementById('throughput').textContent = (throughput).toFixed(2);
      sparkPush(throughput);
      if(selected) updateSide(selected);
    }
    setInterval(tickTelemetry, 800);

    // ---------- Side panel updates ----------
    function updateSide(g){
      const u=g.userData;
      document.getElementById('selId').textContent = u.id;
      document.getElementById('selName').textContent = `${u.name} (${u.type})`;
      document.getElementById('selStatus').textContent = u.state.toUpperCase();
      document.getElementById('selTemp').textContent = `${u.temp.toFixed(1)} °C`;
      document.getElementById('selLoad').textContent = `${(u.load*100).toFixed(0)} %`;
    }

    // ---------- Sparkline ----------
    const spark = document.getElementById('spark');
    const sg = spark.getContext('2d');
    let sparkData = [];
    function sparkDraw(){
      const w = spark.width = spark.clientWidth*2;
      const h = spark.height = spark.clientHeight*2;
      sg.clearRect(0,0,w,h);
      sg.fillStyle = '#07142a';
      sg.fillRect(0,0,w,h);
      // grid
      sg.strokeStyle = '#13325a'; sg.globalAlpha = .6; sg.lineWidth = 1;
      for(let x=0; x<w; x+=w/10){ sg.beginPath(); sg.moveTo(x,0); sg.lineTo(x,h); sg.stroke(); }
      // line
      if(sparkData.length<2) return;
      const max = Math.max(1, ...sparkData);
      const min = 0;
      sg.globalAlpha = 1.0;
      // gradient glow
      const grad = sg.createLinearGradient(0,0,0,h);
      grad.addColorStop(0, '#2dfcff44');
      grad.addColorStop(1, '#00ffa922');
      sg.fillStyle = grad;
      sg.beginPath();
      sparkData.forEach((v,i)=>{
        const x = i/(sparkData.length-1) * (w-4) + 2;
        const y = h - (v-min)/(max-min) * (h-6) - 3;
        if(i===0) sg.moveTo(x,y); else sg.lineTo(x,y);
      });
      sg.lineTo(w-2, h-2); sg.lineTo(2, h-2); sg.closePath(); sg.fill();
      sg.strokeStyle = '#68fff4'; sg.lineWidth = 2.5; sg.globalAlpha = 0.9;
      sg.beginPath();
      sparkData.forEach((v,i)=>{
        const x = i/(sparkData.length-1) * (w-4) + 2;
        const y = h - (v-min)/(max-min) * (h-6) - 3;
        if(i===0) sg.moveTo(x,y); else sg.lineTo(x,y);
      });
      sg.stroke();
    }
    function sparkPush(v){
      sparkData.push(v);
      if(sparkData.length>80) sparkData.shift();
      sparkDraw();
    }
    window.addEventListener('resize', sparkDraw);

    // ---------- UI controls ----------
    const flowRadios = [...document.querySelectorAll('input[name=flow]')];
    flowRadios.forEach(r => r.addEventListener('change', ()=>{
      const mode = Number(document.querySelector('input[name=flow]:checked').value);
      pipeUniforms.uSpeed.value = mode===0? 0.0 : mode===1? 0.55 : 1.4;
    }));
    document.getElementById('btnReset').addEventListener('click', ()=>{
      camera.position.set(12,12,20);
      controls.target.set(6,0,0);
      controls.update();
    });
    let dark = true;
    document.getElementById('btnTheme').addEventListener('click', ()=>{
      dark = !dark;
      scene.background = new THREE.Color(dark?0x08101e:0x0e1c28);
      renderer.toneMappingExposure = dark?1.2:1.0;
    });
    document.getElementById('btnStart').addEventListener('click', ()=> pipeUniforms.uSpeed.value = 0.8);
    document.getElementById('btnStop').addEventListener('click', ()=> pipeUniforms.uSpeed.value = 0.0);
    document.getElementById('btnPulse').addEventListener('click', ()=>{
      // force a brief alert on a random asset
      const g = allAssets[Math.floor(Math.random()*allAssets.length)];
      g.userData.temp = 85 + Math.random()*10;
      g.userData.load = 1.1;
      tickTelemetry();
    });

    // ---------- Animation loop ----------
    let clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      pipeUniforms.uTime.value += dt;

      // move dots along top curve
      dots.forEach(d=>{
        d.t = (d.t + d.speed * (0.3 + pipeUniforms.uSpeed.value)) % 1;
        const pos = topCurve.getPointAt(d.t);
        d.mesh.position.copy(pos);
      });

      controls.update();
      composer.render();
      labelRenderer.render(scene, camera);
    }
    animate();

    // ---------- Resize ----------
    function onResize(){
      const w = container.clientWidth, h = container.clientHeight;
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h);
      composer.setSize(w,h);
      labelRenderer.setSize(w,h);
    }
    window.addEventListener('resize', onResize);

    // Initial telemetry seed
    for(let i=0;i<24;i++) sparkPush(Math.random()*1.2);
    tickTelemetry();
  </script>
</body>
</html>